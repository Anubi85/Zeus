using System;
using System.Runtime.InteropServices;

namespace Zeus.Helpers
{
    /// <summary>
    /// Helper class for native methods from User32 dll.
    /// </summary>
    public static class User32Helper
    {
        #region Methods

        /// <summary>
        /// Installs an application-defined hook procedure into a hook chain.
        /// </summary>
        /// <param name="idHook">The type of hook procedure to be installed.</param>
        /// <param name="lpfn">Hook procedure callback function.</param>
        /// <param name="hMod">A handle to the DLL containing the hook procedure pointed to by the <paramref name="lpfn"/> parameter.</param>
        /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
        /// <returns>Returns the handle of the hook procedureif succeed, <see cref="IntPtr.Zero"/> otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetWindowsHookEx(WH idHook, Delegate lpfn, IntPtr hMod, uint dwThreadId);

        /// <summary>
        /// Removes a hook procedure installed in a hook chain by the <see cref="SetWindowsHookEx(WH, LowLevelKeyboardProc, IntPtr, uint)"/> function
        /// </summary>
        /// <param name="hhk">A handle to the hook to be removed.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnhookWindowsHookEx(IntPtr hhk);

        /// <summary>
        /// Passes the hook information to the next hook procedure in the current hook chain.
        /// </summary>
        /// <param name="hhk">A handle to the hook, this parameter is ignored.</param>
        /// <param name="nCode">The hook code passed to the current hook procedure.</param>
        /// <param name="wParam">The wParam value passed to the current hook procedure.</param>
        /// <param name="lParam">The lParam value passed to the current hook procedure.</param>
        /// <returns>The retrun value of the next hook procedure in the chain.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

        /// <summary>
        /// Retrieves the status of the specified virtual key.
        /// </summary>
        /// <param name="keyCode">Virtual key code to wich retrieve the status.</param>
        /// <returns>Returns the status of the specified virtual key.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern short GetKeyState(int keyCode);

        /// <summary>
        /// Defines a new window message that is guaranteed to be unique throughout the system.
        /// </summary>
        /// <param name="lpString">The message to be registered.</param>
        /// <returns>Returns the message identifiaer in the range 0xC000 - 0xFFFF if succeed, zero otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern uint RegisterWindowMessage(string lpString);

        /// <summary>
        /// Register a system wide hot-key.
        /// </summary>
        /// <param name="hWnd">A handle to the window that will receive <see cref="WM.HOTKEY"/> messages generated by the hot key. </param>
        /// <param name="id">The identifier of the hot key.</param>
        /// <param name="fsModifiers">The keys that must be pressed in combination with the key specified by the
        /// <paramref name="vk"/> parameter in order to generate the <see cref="WM.HOTKEY"/> message. </param>
        /// <param name="vk">The virtual-key code of the hot key.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, MOD fsModifiers, int vk);

        /// <summary>
        /// Frees a hot key previously registered by the calling thread.
        /// </summary>
        /// <param name="hWnd">A handle to the window associated with the hot key to be freed.</param>
        /// <param name="id">The identifier of the hot key to be freed.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        /// <summary>
        /// Calls the default window procedure to provide default processing for any window messages that an application does not process.
        /// </summary>
        /// <param name="hWnd">A handle to the window procedure that received the message.</param>
        /// <param name="Msg">The message.</param>
        /// <param name="wParam">Additional message information. The content of this parameter depends on the value of the <paramref name="Msg"/> parameter.</param>
        /// <param name="lParam">Additional message information. The content of this parameter depends on the value of the <paramref name="Msg"/> parameter.</param>
        /// <returns></returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        /// <summary>
        /// Bring the thread that create the specified window into the foreground and activates the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
        /// <returns>True if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool SetForegroundWindow(IntPtr hWnd);

        #endregion

        #region Delegates

        /// <summary>
        /// Delegate for LowLevelKeyboardProc hooks.
        /// </summary>
        /// <param name="nCode">A code the hook procedure uses to determine how to process the message.
        /// If nCode is less than zero, the hook procedure must pass the message to the <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>
        /// function without further processing and should return the value returned by <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>.</param>
        /// <param name="wParam">The identifier of the keyboard message.</param>
        /// <param name="lParam">A pointer to a <see cref="KBDLLHOOKSTRUCT"/> structure.</param>
        /// <returns>If returns <see cref="IntPtr.Zero"/> other message hooks in the queue are not processed,
        /// otherwise processing continues normally.</returns>
        public delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);
        /// <summary>
        /// Delegate for CallWndProc hooks.
        /// </summary>
        /// <param name="nCode">A code the hook procedure uses to determine how to process the message.
        /// If nCode is less than zero, the hook procedure must pass the message to the <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>
        /// function without further processing and should return the value returned by <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>.</param>
        /// <param name="wParam">Specifies whether the message was sent by the current thread. If the message was sent by the current thread, it is nonzero; otherwise, it is zero.</param>
        /// <param name="lParam">A pointer to a <see cref="CWPSTRUCT"/> structure that contains details about the message..</param>
        /// <returns>If returns <see cref="IntPtr.Zero"/> other message hooks in the queue are not processed,
        /// otherwise processing continues normally.</returns>
        public delegate IntPtr CallWndProc(int nCode, IntPtr wParam, IntPtr lParam);

        #endregion

        #region Structures

#pragma warning disable 0649
        /// <summary>
        /// Contains information about a low-level keyboard input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct KBDLLHOOKSTRUCT
        {
            /// <summary>
            /// A virtual-key code.
            /// </summary>
            public int vkCode;
            /// <summary>
            /// A hardware scan code for the key.
            /// </summary>
            public uint scanCode;
            /// <summary>
            /// The extended-key flag, event-injected flags, context code, and transition-state flag.
            /// </summary>
            public LLKHF flags;
            /// <summary>
            /// The time stamp for this message.
            /// </summary>
            public uint time;
            /// <summary>
            /// Additional information associated with the message.
            /// </summary>
            public IntPtr dwExtraInfo;
        }
#pragma warning restore 0649

        /// <summary>
        /// Contains information about a not yet processed message sent to the thread.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct CWPSTRUCT
        {
            /// <summary>
            /// Additional information about the message. The exact meaning depends on the <see cref="message"/> value.
            /// </summary>
            public IntPtr lParam;
            /// <summary>
            /// Additional information about the message. The exact meaning depends on the <see cref="message"/> value.
            /// </summary>
            public IntPtr wParam;
            /// <summary>
            /// The message.
            /// </summary>
            public uint message;
            /// <summary>
            /// A handle to the window to receive the message.
            /// </summary>
            public IntPtr hwnd;
        }

        #endregion

        #region Enums

        /// <summary>
        /// Modifier key flags.
        /// </summary>
        [Flags]
        public enum MOD
        {
            /// <summary>
            /// Either ALT key must be held down.
            /// </summary>
            ALT = 0x0001,
            /// <summary>
            /// Either CTRL key must be held down.
            /// </summary>
            CONTROL = 0x0002,
            /// <summary>
            /// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
            /// </summary>
            NOREPEAT = 0x4000,
            /// <summary>
            /// Either SHIFT key must be held down.
            /// </summary>
            SHIFT = 0x0004,
            /// <summary>
            /// Either WINDOWS key was held down.
            /// </summary>
            WIN = 0x0008,
        }

        /// <summary>
        /// <see cref="KBDLLHOOKSTRUCT.flags"/> values.
        /// </summary>
        [Flags]
        public enum LLKHF
        {
            /// <summary>
            /// Test the extended-key flag.
            /// </summary>
            EXTENDED = 0x01,
            /// <summary>
            /// Test the event-injected (from a process running at lower integrity level) flag.
            /// </summary>
            LOWER_IL_INJECTED = 0x02,
            /// <summary>
            /// Test the event-injected (from any process) flag.
            /// </summary>
            INJECTED = 0x10,
            /// <summary>
            /// Test the context code.
            /// </summary>
            ALTDOWN = 0x20,
            /// <summary>
            /// Test the transition-state flag.
            /// </summary>
            UP = 0x80,
        }

        /// <summary>
        /// Hook procedure types.
        /// </summary>
        public enum WH
        {
            /// <summary>
            /// Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box,
            /// message box, menu, or scroll bar.
            /// </summary>
            MSGFILTER = -1,
            /// <summary>
            /// Installs a hook procedure that records input messages posted to the system message queue.
            /// </summary>
            JOURNALRECORD = 0x00,
            /// <summary>
            /// Installs a hook procedure that posts messages previously recorded by a <see cref="WH.JOURNALRECORD"/> hook procedure.
            /// </summary>
            JOURNALPLAYBACK = 0x01,
            /// <summary>
            /// Installs a hook procedure that monitors keystroke messages.
            /// </summary>
            KEYBOARD = 0x02,
            /// <summary>
            /// Installs a hook procedure that monitors messages posted to a message queue.
            /// </summary>
            GETMESSAGE = 0x03,
            /// <summary>
            /// Installs a hook procedure that monitors messages before the system sends them to the destination window procedure.
            /// </summary>
            CALLWNDPROC = 0x04,
            /// <summary>
            /// Installs a hook procedure that receives notifications useful to a CBT application.
            /// </summary>
            CBT = 0x05,
            /// <summary>
            /// Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box,
            /// message box, menu, or scroll bar. 
            /// </summary>
            SYSMSGFILTER = 0x06,
            /// <summary>
            /// Installs a hook procedure that monitors mouse messages.
            /// </summary>
            MOUSE = 0x07,
            /// <summary>
            /// Installs a hook procedure useful for debugging other hook procedures.
            /// </summary>
            DEBUG = 0x09,
            /// <summary>
            /// Installs a hook procedure that receives notifications useful to shell applications.
            /// </summary>
            SHELL = 0x0A,
            /// <summary>
            /// Installs a hook procedure that will be called when the application's foreground thread is about to become idle.
            /// </summary>
            FOREGROUNDIDLE = 0x0B,
            /// <summary>
            /// Installs a hook procedure that monitors messages after they have been processed by the destination window procedure.
            /// </summary>
            CALLWNDPROCRET = 0x0C,
            /// <summary>
            /// Installs a hook procedure that monitors low-level keyboard input events.
            /// </summary>
            KEYBOARD_LL = 0x0D,
            /// <summary>
            /// Installs a hook procedure that monitors low-level mouse input events.
            /// </summary>
            MOUSE_LL = 0x0E,
        }

        /// <summary>
        /// Window messages.
        /// </summary>
        public enum WM
        {
            /// <summary>
            /// Performs no operation.
            /// </summary>
            NULL = 0x0000,
            /// <summary>
            /// Sent when an application requests that a window be created.
            /// The window procedure of the new window receives this message after the window is created, but before the window becomes visible.
            /// </summary>
            CREATE = 0x0001,
            /// <summary>
            /// Sent when a window is being destroyed.
            /// It is sent to the window procedure of the window being destroyed after the window is removed from the screen.
            /// This message is sent first to the window being destroyed and then to the child windows (if any) as they are destroyed.
            /// During the processing of the message, it can be assumed that all child windows still exist.
            /// </summary>
            DESTROY = 0x0002,
            /// <summary>
            /// Sent after a window has been moved.
            /// </summary>
            MOVE = 0x0003,
            /// <summary>
            /// Sent to a window after its size has changed.
            /// </summary>
            SIZE = 0x0005,
            /// <summary>
            /// Sent when an application changes the enabled state of a window.
            /// </summary>
            ENABLE = 0x000A,
            /// <summary>
            /// Sent as a signal that a window or an application should terminate.
            /// </summary>
            CLOSE = 0x0010,
            /// <summary>
            /// Indicates a request to terminate an application.
            /// </summary>
            QUIT = 0x0012,
            /// <summary>
            /// Sent to an icon when the user requests that the window be restored to its previous size and position.
            /// </summary>
            QUERYOPEN = 0x0013,
            /// <summary>
            /// Sent to a window when the window is about to be hidden or shown.
            /// </summary>
            SHOWWINDOW = 0x0018,
            /// <summary>
            /// Sent when a window belonging to a different application than the active window is about to be activated.
            /// The message is sent to the application whose window is being activated and to the application whose window is being deactivated.
            /// </summary>
            ACTIVATEAPP = 0x001C,
            /// <summary>
            /// Sent to cancel certain modes, such as mouse capture. 
            /// Certain functions also send this message explicitly to the specified window regardless of whether it is the active window. 
            /// </summary>
            CANCELMODE = 0x001F,
            /// <summary>
            /// Sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.
            /// </summary>
            CHILDACTIVATE = 0x0022,
            /// <summary>
            /// Sent to a window when the size or position of the window is about to change.
            /// </summary>
            GETMINMAXINFO = 0x0024,
            /// <summary>
            /// Sent to a minimized (iconic) window.
            /// The window is about to be dragged by the user but does not have an icon defined for its class.
            /// </summary>
            QUERYDRAGICON = 0x0037,
            /// <summary>
            ///Sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory.
            ///This indicates that system memory is low. 
            /// </summary>
            COMPACTING = 0x0041,
            /// <summary>
            /// Sent to a window whose size, position, or place in the Z order is about to change.
            /// </summary>
            WINDOWPOSCHANGING = 0x0046,
            /// <summary>
            /// Sent to a window whose size, position, or place in the Z order has changed.
            /// </summary>
            WINDOWPOSCHANGED = 0x0047,
            /// <summary>
            /// Posted to the window with the focus when the user chooses a new input language,
            /// either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar.
            /// </summary>
            INPUTLANGCHANGEREQUEST = 0x0050,
            /// <summary>
            /// Sent to the topmost affected window after an application's input language has been changed.
            /// </summary>
            INPUTLANGCHANGE = 0x0051,
            /// <summary>
            /// Sent to all windows after the user has logged on or off.
            /// </summary>
            USERCHANGED = 0x0054,
            /// <summary>
            /// Sent to a window when one or more of the window's styles is about to change.
            /// </summary>
            STYLECHANGING = 0x007C,
            /// <summary>
            /// Sent to a window after one or more of the window's styles has changed.
            /// </summary>
            STYLECHANGED = 0x007D,
            /// <summary>
            /// Sent to a window to retrieve a handle to the large or small icon associated with a window.
            /// </summary>
            GETICON = 0x007F,
            /// <summary>
            /// Sent prior to the <see cref="CREATE"/> message when a window is first created.
            /// </summary>
            NCCREATE = 0x0081,
            /// <summary>
            /// Notifies a window that its nonclient area is being destroyed.
            /// </summary>
            NCDESTROY = 0x0082,
            /// <summary>
            /// Sent when the size and position of a window's client area must be calculated.
            /// </summary>
            NCCALCSIZE = 0x0083,
            /// <summary>
            /// Sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.
            /// </summary>
            NCACTIVATE = 0x0086,
            /// <summary>
            /// Posted to the window with the keyboard focus when a nonsystem key is pressed.
            /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
            /// </summary>
            KEYDOWN = 0x0100,
            /// <summary>
            /// Posted to the window with the keyboard focus when a nonsystem key is released.
            /// A nonsystem key is a key that is pressed when the ALT key is not pressed,
            /// or a keyboard key that is pressed when a window has the keyboard focus.
            /// </summary>
            KEYUP = 0x0101,
            /// <summary>
            /// Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar)
            /// or holds down the ALT key and then presses another key.
            /// It also occurs when no window currently has the keyboard focus.
            /// </summary>
            SYSKEYDOWN = 0x0104,
            /// <summary>
            /// Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.
            /// It also occurs when no window currently has the keyboard focus.
            /// </summary>
            SYSKEYUP = 0x0105,
            /// <summary>
            /// Posted to a window when the cursor moves.
            /// </summary>
            MOUSEMOVE = 0x0200,
            /// <summary>
            /// Posted when the user presses the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONDOWN = 0x0201,
            /// <summary>
            /// Posted when the user releases the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONUP = 0x0202,
            /// <summary>
            /// Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONDBLCLK = 0x0203,
            /// <summary>
            /// Posted when the user presses the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONDOWN = 0x0204,
            /// <summary>
            /// Posted when the user releases the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONUP = 0x0205,
            /// <summary>
            /// Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONDBLCLK = 0x0206,
            /// <summary>
            /// Posted when the user presses the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONDOWN = 0x0207,
            /// <summary>
            /// Posted when the user releases the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONUP = 0x0208,
            /// <summary>
            /// Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONDBLCLK = 0x0209,
            /// <summary>
            /// Sent to the focus window when the mouse wheel is rotated.
            /// </summary>
            MOUSEWHEEL = 0x020A,
            /// <summary>
            /// Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.
            /// </summary>
            MOUSEHWHEEL = 0x020E,
            /// <summary>
            /// Sent to a window that the user is resizing.
            /// </summary>
            SIZING = 0x0214,
            /// <summary>
            /// Sent to a window that the user is moving.
            /// </summary>
            MOVING = 0x0216,
            /// <summary>
            /// Sent one time to a window after it enters the moving or sizing modal loop.
            /// </summary>
            ENTERSIZEMOVE = 0x0231,
            /// <summary>
            /// Sent one time to a window, after it has exited the moving or sizing modal loop.
            /// </summary>
            EXITSIZEMOVE = 0x0232,
            /// <summary>
            /// Sent when the effective dots per inch (dpi) for a window has changed.
            /// </summary>
            DPICHANGED = 0x02E0,
            /// <summary>
            /// Posted when the user presses a hot key registered by the <see cref="User32Helper.RegisterHotKey(IntPtr, int, int, int)"/> function.
            /// </summary>
            HOTKEY = 0x0312,
            /// <summary>
            /// Broadcast to every window following a theme change event.
            /// </summary>
            THEMECHANGED = 0x031A,
        }

        #endregion
    }
}
