using System;
using System.Runtime.InteropServices;

namespace Zeus.Helpers
{
    /// <summary>
    /// Helper class for native methods from User32 dll.
    /// </summary>
    public static class User32Helper
    {
        #region Methods

        /// <summary>
        /// Installs an application-defined hook procedure into a hook chain.
        /// </summary>
        /// <param name="idHook">The type of hook procedure to be installed.</param>
        /// <param name="lpfn">Hook procedure callback function.</param>
        /// <param name="hMod">A handle to the DLL containing the hook procedure pointed to by the <paramref name="lpfn"/> parameter.</param>
        /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated.</param>
        /// <returns>Returns the handle of the hook procedureif succeed, <see cref="IntPtr.Zero"/> otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetWindowsHookEx(WH idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

        /// <summary>
        /// Removes a hook procedure installed in a hook chain by the <see cref="SetWindowsHookEx(WH, LowLevelKeyboardProc, IntPtr, uint)"/> function
        /// </summary>
        /// <param name="hhk">A handle to the hook to be removed.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnhookWindowsHookEx(IntPtr hhk);

        /// <summary>
        /// Passes the hook information to the next hook procedure in the current hook chain.
        /// </summary>
        /// <param name="hhk">A handle to the hook, this parameter is ignored.</param>
        /// <param name="nCode">The hook code passed to the current hook procedure.</param>
        /// <param name="wParam">The wParam value passed to the current hook procedure.</param>
        /// <param name="lParam">The lParam value passed to the current hook procedure.</param>
        /// <returns>The retrun value of the next hook procedure in the chain.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, int wParam, IntPtr lParam);

        /// <summary>
        /// Retrieves the status of the specified virtual key.
        /// </summary>
        /// <param name="keyCode">Virtual key code to wich retrieve the status.</param>
        /// <returns>Returns the status of the specified virtual key.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern short GetKeyState(int keyCode);

        /// <summary>
        /// Defines a new window message that is guaranteed to be unique throughout the system.
        /// </summary>
        /// <param name="lpString">The message to be registered.</param>
        /// <returns>Returns the message identifiaer in the range 0xC000 - 0xFFFF if succeed, zero otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern uint RegisterWindowMessage(string lpString);

        /// <summary>
        /// Register a system wide hot-key.
        /// </summary>
        /// <param name="hWnd">A handle to the window that will receive <see cref="WM.HOTKEY"/> messages generated by the hot key. </param>
        /// <param name="id">The identifier of the hot key.</param>
        /// <param name="fsModifiers">The keys that must be pressed in combination with the key specified by the
        /// <paramref name="vk"/> parameter in order to generate the <see cref="WM.HOTKEY"/> message. </param>
        /// <param name="vk">The virtual-key code of the hot key.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, MOD fsModifiers, int vk);

        /// <summary>
        /// Frees a hot key previously registered by the calling thread.
        /// </summary>
        /// <param name="hWnd">A handle to the window associated with the hot key to be freed.</param>
        /// <param name="id">The identifier of the hot key to be freed.</param>
        /// <returns>Returns true if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        /// <summary>
        /// Calls the default window procedure to provide default processing for any window messages that an application does not process.
        /// </summary>
        /// <param name="hWnd">A handle to the window procedure that received the message.</param>
        /// <param name="Msg">The message.</param>
        /// <param name="wParam">Additional message information. The content of this parameter depends on the value of the <paramref name="Msg"/> parameter.</param>
        /// <param name="lParam">Additional message information. The content of this parameter depends on the value of the <paramref name="Msg"/> parameter.</param>
        /// <returns></returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        /// <summary>
        /// Bring the thread that create the specified window into the foreground and activates the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
        /// <returns>True if succeed, false otherwise.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool SetForegroundWindow(IntPtr hWnd);

        #endregion

        #region Delegates

        /// <summary>
        /// Delegate for LowLevelKeyboardProc hooks.
        /// </summary>
        /// <param name="nCode">A code the hook procedure uses to determine how to process the message.
        /// If nCode is less than zero, the hook procedure must pass the message to the <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>
        /// function without further processing and should return the value returned by <see cref="CallNextHookEx(IntPtr, int, int, IntPtr)"/>.</param>
        /// <param name="wParam">The identifier of the keyboard message.</param>
        /// <param name="lParam">A pointer to a <see cref="KBDLLHOOKSTRUCT"/> structure.</param>
        /// <returns>If returns <see cref="IntPtr.Zero"/> other message hooks in the queue are not processed,
        /// otherwise processing continues normally.</returns>
        public delegate IntPtr LowLevelKeyboardProc(int nCode, WM wParam, IntPtr lParam);

        #endregion

        #region Structures

#pragma warning disable 0649
        /// <summary>
        /// Contains information about a low-level keyboard input event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct KBDLLHOOKSTRUCT
        {
            /// <summary>
            /// A virtual-key code.
            /// </summary>
            public int vkCode;
            /// <summary>
            /// A hardware scan code for the key.
            /// </summary>
            public uint scanCode;
            /// <summary>
            /// The extended-key flag, event-injected flags, context code, and transition-state flag.
            /// </summary>
            public LLKHF flags;
            /// <summary>
            /// The time stamp for this message.
            /// </summary>
            public uint time;
            /// <summary>
            /// Additional information associated with the message.
            /// </summary>
            public IntPtr dwExtraInfo;
        }
#pragma warning restore 0649

        #endregion

        #region Enums

        /// <summary>
        /// Modifier key flags.
        /// </summary>
        [Flags]
        public enum MOD
        {
            /// <summary>
            /// Either ALT key must be held down.
            /// </summary>
            ALT = 0x0001,
            /// <summary>
            /// Either CTRL key must be held down.
            /// </summary>
            CONTROL = 0x0002,
            /// <summary>
            /// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
            /// </summary>
            NOREPEAT = 0x4000,
            /// <summary>
            /// Either SHIFT key must be held down.
            /// </summary>
            SHIFT = 0x0004,
            /// <summary>
            /// Either WINDOWS key was held down.
            /// </summary>
            WIN = 0x0008,
        }

        /// <summary>
        /// <see cref="KBDLLHOOKSTRUCT.flags"/> values.
        /// </summary>
        [Flags]
        public enum LLKHF
        {
            /// <summary>
            /// Test the extended-key flag.
            /// </summary>
            EXTENDED = 0x01,
            /// <summary>
            /// Test the event-injected (from a process running at lower integrity level) flag.
            /// </summary>
            LOWER_IL_INJECTED = 0x02,
            /// <summary>
            /// Test the event-injected (from any process) flag.
            /// </summary>
            INJECTED = 0x10,
            /// <summary>
            /// Test the context code.
            /// </summary>
            ALTDOWN = 0x20,
            /// <summary>
            /// Test the transition-state flag.
            /// </summary>
            UP = 0x80,
        }

        /// <summary>
        /// Hook procedure types.
        /// </summary>
        public enum WH
        {
            /// <summary>
            /// Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box,
            /// message box, menu, or scroll bar.
            /// </summary>
            MSGFILTER = -1,
            /// <summary>
            /// Installs a hook procedure that records input messages posted to the system message queue.
            /// </summary>
            JOURNALRECORD = 0x00,
            /// <summary>
            /// Installs a hook procedure that posts messages previously recorded by a <see cref="WH.JOURNALRECORD"/> hook procedure.
            /// </summary>
            JOURNALPLAYBACK = 0x01,
            /// <summary>
            /// Installs a hook procedure that monitors keystroke messages.
            /// </summary>
            KEYBOARD = 0x02,
            /// <summary>
            /// Installs a hook procedure that monitors messages posted to a message queue.
            /// </summary>
            GETMESSAGE = 0x03,
            /// <summary>
            /// Installs a hook procedure that monitors messages before the system sends them to the destination window procedure.
            /// </summary>
            CALLWNDPROC = 0x04,
            /// <summary>
            /// Installs a hook procedure that receives notifications useful to a CBT application.
            /// </summary>
            CBT = 0x05,
            /// <summary>
            /// Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box,
            /// message box, menu, or scroll bar. 
            /// </summary>
            SYSMSGFILTER = 0x06,
            /// <summary>
            /// Installs a hook procedure that monitors mouse messages.
            /// </summary>
            MOUSE = 0x07,
            /// <summary>
            /// Installs a hook procedure useful for debugging other hook procedures.
            /// </summary>
            DEBUG = 0x09,
            /// <summary>
            /// Installs a hook procedure that receives notifications useful to shell applications.
            /// </summary>
            SHELL = 0x0A,
            /// <summary>
            /// Installs a hook procedure that will be called when the application's foreground thread is about to become idle.
            /// </summary>
            FOREGROUNDIDLE = 0x0B,
            /// <summary>
            /// Installs a hook procedure that monitors messages after they have been processed by the destination window procedure.
            /// </summary>
            CALLWNDPROCRET = 0x0C,
            /// <summary>
            /// Installs a hook procedure that monitors low-level keyboard input events.
            /// </summary>
            KEYBOARD_LL = 0x0D,
            /// <summary>
            /// Installs a hook procedure that monitors low-level mouse input events.
            /// </summary>
            MOUSE_LL = 0x0E,
        }

        /// <summary>
        /// Window messages.
        /// </summary>
        public enum WM
        {
            /// <summary>
            /// Posted to the window with the keyboard focus when a nonsystem key is pressed.
            /// A nonsystem key is a key that is pressed when the ALT key is not pressed.
            /// </summary>
            KEYDOWN = 0x0100,
            /// <summary>
            /// Posted to the window with the keyboard focus when a nonsystem key is released.
            /// A nonsystem key is a key that is pressed when the ALT key is not pressed,
            /// or a keyboard key that is pressed when a window has the keyboard focus.
            /// </summary>
            KEYUP = 0x0101,
            /// <summary>
            /// Posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar)
            /// or holds down the ALT key and then presses another key.
            /// It also occurs when no window currently has the keyboard focus.
            /// </summary>
            SYSKEYDOWN = 0x0104,
            /// <summary>
            /// Posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down.
            /// It also occurs when no window currently has the keyboard focus.
            /// </summary>
            SYSKEYUP = 0x0105,
            /// <summary>
            /// Posted to a window when the cursor moves.
            /// </summary>
            MOUSEMOVE = 0x0200,
            /// <summary>
            /// Posted when the user presses the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONDOWN = 0x0201,
            /// <summary>
            /// Posted when the user releases the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONUP = 0x0202,
            /// <summary>
            /// Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.
            /// </summary>
            LBUTTONDBLCLK = 0x0203,
            /// <summary>
            /// Posted when the user presses the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONDOWN = 0x0204,
            /// <summary>
            /// Posted when the user releases the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONUP = 0x0205,
            /// <summary>
            /// Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.
            /// </summary>
            RBUTTONDBLCLK = 0x0206,
            /// <summary>
            /// Posted when the user presses the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONDOWN = 0x0207,
            /// <summary>
            /// Posted when the user releases the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONUP = 0x0208,
            /// <summary>
            /// Posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window.
            /// </summary>
            MBUTTONDBLCLK = 0x0209,
            /// <summary>
            /// Sent to the focus window when the mouse wheel is rotated.
            /// </summary>
            MOUSEWHEEL = 0x020A,
            /// <summary>
            /// Sent to the active window when the mouse's horizontal scroll wheel is tilted or rotated.
            /// </summary>
            MOUSEHWHEEL = 0x020E,
            /// <summary>
            /// Posted when the user presses a hot key registered by the <see cref="RegisterHotKey(IntPtr, int, int, int)"/> function.
            /// </summary>
            HOTKEY = 0x0312,
        }

        #endregion
    }
}
